<link rel="stylesheet" type="text/css" href="style.css">

# Documentation

## Activations

`class Activations(network, input)`

Holds the activation pattern generated in a neural network

#### Parameters

|Parameter|Description|
|---|---|
|`network: torch.nn.Module`|Pytroch neural network.|
|`input: torch.tensor`|A valid single input to the network. For later computations make sure to pass a single input, i.e. `batch_size = 1`.|

#### Attributes

|Attribute|Description|
|---|---|
|`layernames: [String]`|Holds the names of the children modules, i.e. layer names, of the network in a list.|
|`layerdescriptions: [torch.nn]`|Holds the children modules, i.e. layer types and specifications, of the network in a list.|
|`layeractivations: [torch.tensor]`|Holds the activations of every child module, i.e. values of the activation pattern, in a list.|

#### Methods

|Method|Description|
|---|---|
|`to_vector()`|Get and reshape the `layeractivations` into a vector.<br>Returns `list`.|
|`to_activations(signal)`|Create object `Activatitions` like `self` but with `layeractivations` according to vector `signal: list` or `signal: ndarray`.<br>Returns `Activations`.|

## NNGraph

`class NNGraph(activations, INCL=True)`

Directed graph representing in the computational graph structure of a Pytorch neural network.

#### Parameters

|Parameter|Description|
|---|---|
|`activations: Activations`|Pass any sample activation pattern generated by the network under observation. The resulting `NNGraph` is independent of the activation values contained in the specific activation pattern, i.e. `activation.layeractivations`.|
|`INCL: boolean`|Optional parameter. If set to `True`, it includes edges in the NNGraph even if the weight of the edge in the neural network is `0`. If set to `False`, only edges with weight unequal to `0` are added to the graph. Especially, `INCL = False` will only have one incoming edge per activation in  a `torch.nn.MaxPool` layer.|


#### Attributes

|Attribute|Description|
|---|---|
|`inv_F: scipy.sparse.tril(A, format='csr')`|Inverse Fourier Transform matrix w.r.t. [[1]](https://arxiv.org/pdf/2012.04358.pdf) and [[2]](https://acl.inf.ethz.ch/research/ASP/). Is `None` until the first invocation of `NNGraph.transform(activations, type='standard')` or can be explicitly assigned by calling `NNGraph.compute_transformer(type='standard')`.|
|`lu_piv: ndarray, ndarray`|LU-decomposition of the inverse Fourier Transform matrix w.r.t. [[3]](https://arxiv.org/pdf/1211.0053.pdf). Is `None` until the first invocation of `NNGraph.transform(activations, type='laplacian')` or can be explicitly assigned by calling `NNGraph.compute_transformer(type='laplacian')`.|


#### Methods

|Method|Description|
|---|---|
|`compute_transformer(type='standard')`|If `type='standard'` it computes the inverse Fourier Transform matrix w.r.t. [[1]](https://arxiv.org/pdf/2012.04358.pdf) and [[2]](https://acl.inf.ethz.ch/research/ASP/).<br>Returns [`scipy.sparse.tril(A, format='csr')`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.tril.html). If `type='laplacian'` it computes the inverse Fourier Transform matrix w.r.t. [[3]](https://arxiv.org/pdf/1211.0053.pdf).<br>Returns [`lu, piv: ndarray, ndarray`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lu_factor.html).|
|`transform(activations, type='standard')`|Compute the Fourier coefficients, or spectrum, of the `activations`. If `type='standard'` the Fourer coefficient w.r.t. [[1]](https://arxiv.org/pdf/2012.04358.pdf) and [2]](https://acl.inf.ethz.ch/research/ASP/) are computed. If `type='laplacian'` the Fourer coefficient w.r.t. [[3]](https://arxiv.org/pdf/1211.0053.pdf) are computed. Returns `Activations`.|
|`node_id(node)`|Get the index of a node in the `NNGraph` in the total order of all nodes.<br>Returns `int`.|

## Visualizer

`class Visualizer`

Plot the generated data.

#### Methods

|Method|Description|
|---|---|
|`visualize_pattern(activations, pdf_filepath, scale='layerscale', cmap_style='viridis')`|Visualize `activations: Activations` and store them at `pdf_filepath: String`.<br>`scale='layerscale'` provides one scale, i.e. colorbar, per activation layer. `scale='globalscale'` provides one scale per activation pattern. `scale='layernorm'` provides one scale per activation layer and sets the center of the scale to 0. `scale='globalnorm'` provides one scale per activation pattern and sets the center of the scale to 0. `scale='layernorm'` and `scale='globalnorm'` are particularly useful for diverging colormap styles. Pick a `cmap_style` from [matplotlib colormaps](https://matplotlib.org/stable/tutorials/colors/colormaps.html).<br>Returns `None`|

## OutputLoader

`class OutputLoader`

Store and load intermediate results. Especially useful for storing `NNGraph` and `Transformers` since their computations take long and they can be used to transform multiple `Activations`.

#### Methods

|Method|Description|
|---|---|
|`save(obj, path)`|Store python object like `Activations` or `NNGrpah` at the specified `path: String`.<br>Returns `None`.|
|`load(path)`|Load python object like `Activations` or `NNGrpah` at the specified `path: String`.<br>Returns `object`.|


## References
[1]
Markus Püschel, Bastian Seifert, and Chris Wendler. Discrete signal processing on meet/join lattices. IEEE Transactions on Signal Processing, 2021.

[2]
Bastian Seifert, Chris Wendler and Markus Püschel. A Causal Shift and Fourier Transform for Directed Acyclic Graphs. Submitted for publication, 2021.

[3]
David I Shuman, Sunil K Narang, Pascal Frossard, Antonio Ortega, and Pierre Vandergheynst. The emerging field of signal processing on graphs: Extending high-dimensional data analysis to networks and other irregular domains. IEEE signal processing magazine, 30(3):83–98, 2013.
